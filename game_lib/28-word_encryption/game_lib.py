import os
import random
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn
import argparse
def parse_init():
    """
    定义并解析eval代码的命令行参数，配置日志记录，并检查输入的数据文件目录和输出的目录是否存在。
    """
    parser = argparse.ArgumentParser(description="Data creation utility")

    # 添加命令行参数
    parser.add_argument('-p', '--port', type=int, default=8775, help='服务部署端口')
    # 添加命令行参数
    parser.add_argument('-H', '--host', type=str, default="0.0.0.0", help='服务部署地址')
    # 解析命令行参数
    args = parser.parse_args()
    return args
game_prompt="""
You are a good game player, I'll give you a game board and rules.\nYour task is:\n- First, give your answer according to the game board and rules.\n- Second, output the answer in the required format. The last line of your response should be in the following format: 'Answer: $YOUR_ANSWER' (without quotes), where YOUR_ANSWER is your final answer to the question,e.g.'Answer: 12'
{board}
"""
# ------------------------------
# 读取单词及辅助函数
# ------------------------------
words = []
mapping_table_str = """
'A': '😀🍎🚗', 'B': '🐶🌟📚', 'C': '🌈🍀🚀', 'D': '🐱🍉🏀',
        'E': '🍔🎉🎈', 'F': '🌸🍩🏰', 'G': '🦋🍇⚽', 'H': '🍕🎂🏝️',
        'I': '🍦🎁🎧', 'J': '🐸🍒🏆', 'K': '🦄🍓🎮', 'L': '🐰🍍📷',
        'M': '🌹🍌🎨', 'N': '🐼🍎🎤', 'O': '🍉🎵📚', 'P': '🌼🍇🎬',
        'Q': '🐢🍓🎯', 'R': '🍒🎸📱', 'S': '🌻🍍🎲', 'T': '🐯🍌🎮',
        'U': '🍓🎹📖', 'V': '🌺🍉🎥', 'W': '🐳🍎🎭', 'X': '🍍🎤📡',
        'Y': '🐥🍇🎨', 'Z': '🌵🍒🎮'
"""
try:
    with open("words.txt", "r", encoding="utf-8") as f:
        for line in f:
            w = line.strip()
            if len(w) <= 2:
                continue
            words.append(w)
except Exception as e:
    raise Exception("读取 words.txt 出错: " + str(e))

# ------------------------------
# 辅助转换函数
# ------------------------------
def char_drift(c):
    # 将字母向后移动一位，z 后回到 a
    return chr((ord(c) - ord('a') + 1) % 26 + ord('a'))

def char2emoji(c):
    mapping = {
        'A': '😀🍎🚗', 'B': '🐶🌟📚', 'C': '🌈🍀🚀', 'D': '🐱🍉🏀',
        'E': '🍔🎉🎈', 'F': '🌸🍩🏰', 'G': '🦋🍇⚽', 'H': '🍕🎂🏝️',
        'I': '🍦🎁🎧', 'J': '🐸🍒🏆', 'K': '🦄🍓🎮', 'L': '🐰🍍📷',
        'M': '🌹🍌🎨', 'N': '🐼🍎🎤', 'O': '🍉🎵📚', 'P': '🌼🍇🎬',
        'Q': '🐢🍓🎯', 'R': '🍒🎸📱', 'S': '🌻🍍🎲', 'T': '🐯🍌🎮',
        'U': '🍓🎹📖', 'V': '🌺🍉🎥', 'W': '🐳🍎🎭', 'X': '🍍🎤📡',
        'Y': '🐥🍇🎨', 'Z': '🌵🍒🎮'
    }
    new_mapping = {k.lower(): v for k, v in mapping.items()}
    return new_mapping.get(c, c)

def Transform_1(word):
    # 每个字母重复两次，例如 "happy" -> "hhaappppyy"
    return "".join([c * 2 for c in word])

def Transform_2(word):
    # 每个字母右移一位，例如 "happy" -> "ibqqz"
    return "".join([char_drift(c) for c in word])

def Transform_3(word):
    # 字符串循环右移一位，例如 "happy" -> "yhapp"
    return word[-1] + word[:-1] if word else word

def Transform_4(word):
    # 反转字符串，例如 "happy" -> "yppah"
    return word[::-1]

def Transform_5(word):
    # 字符串左移两位，例如 "happy" -> "ppyha"
    return word[2:] + word[:2] if len(word) > 2 else word

def Transform_6(word):
    # 对偶数位置的字母进行轮转，例如 "happy" -> "hbpqy"
    return "".join([char_drift(c) if i % 2 == 0 else c for i, c in enumerate(word)])

def Transform_7(word):
    # 对奇数位置的字母进行轮转，例如 "happy" -> "iaqpz"
    return "".join([char_drift(c) if i % 2 == 1 else c for i, c in enumerate(word)])

def Transform_8(word):
    # 将字母转换为对应的 emoji 字符串
    return "".join([char2emoji(c) for c in word])

rule_functions = {
    "Transform_1": Transform_1,
    "Transform_2": Transform_2,
    "Transform_3": Transform_3,
    "Transform_4": Transform_4,
    "Transform_5": Transform_5,
    "Transform_6": Transform_6,
    "Transform_7": Transform_7,
    "Transform_8": Transform_8,
}

def compute_transformed_word(word, rules):
    for rule in rules:
        word = rule_functions[rule](word)
    return word

desc = f"""This game provides you with a transformed word generated by applying a series of transformations on an original word.
Your task is to recover the original word.
Transformations:
Transform_1: Repeat each letter (e.g. "happy" -> "hhaappppyy").
Transform_2: Shift each letter to the next letter (e.g. "happy" -> "ibqqz").
Transform_3: Cyclic shift right by one (e.g. "happy" -> "yhapp").
Transform_4: Reverse the word (e.g. "happy" -> "yppah").
Transform_5: Cyclic shift left by two (e.g. "happy" -> "ppyha").
Transform_6: Shift even-indexed letters (e.g. "happy" -> "hbpqy").
Transform_7: Shift odd-indexed letters (e.g. "happy" -> "iaqpz").
Transform_8: Convert letters to emojis.Mapping table:{mapping_table_str}
"""

# ------------------------------
# 接口1：generate
# ------------------------------
def generate(seed: int) -> dict:
    """
    根据给定种子生成游戏状态：
      1. 从 words.txt 中读取合法单词（长度大于2）；
      2. 随机生成一系列转换规则（2至10个，最后一条固定为 Transform_8）；
      3. 随机选择一个原始单词并计算转换后的单词；
      4. 构造提示信息。
    返回的 item 包含隐藏的原始单词、转换规则及转换后的单词。
    """
    random.seed(seed)
    if not words:
        raise Exception("words.txt 中未找到合法单词。")
    
    # 生成随机转换规则数量（至少2个规则，最多10个规则）
    rules_num = random.randint(2, 10)
    rules = []
    for i in range(rules_num - 1):
        k = random.choice(list(range(1, 8)))
        rules.append("Transform_%d" % k)
    rules.append("Transform_8")  # 最后一条规则固定为 Transform_8

    original_word = random.choice(words)
    transformed_word = compute_transformed_word(original_word, rules)
    
    prompt_text = (
        "Game rules: " + desc + "\n" +
        "Transformed word: " + transformed_word + "\n" +
        "Transforms applied: " + ", ".join(rules) + "\n" +
        "Please recover the original word from the above transformed word.\n"
    )
    
    item = {
        "answer": "",
        "question": prompt_text,
        "score": 0,
        "is_end": False,
        "response": [],
        "prompt": "",
        "action": "",
        "epoch": 1,
        "original_word": original_word,        # 隐藏的原始单词，仅用于验证
        "rules": rules,
        "transformed_word": transformed_word,  # 显示给玩家的转换结果
    }
    return item

# ------------------------------
# 接口2：print_board
# ------------------------------
def print_board(item: dict) -> str:
    """
    返回生成的游戏提示信息。
    """
    return game_prompt.format(board = item.get("question", ""))

# ------------------------------
# 接口3：verify
# ------------------------------
def verify(item: dict) -> dict:
    """
    根据 item 中的 action（玩家输入的答案）校验答案是否正确：
      1. 获取隐藏的原始单词；
      2. 比较玩家输入答案与原始单词，完全匹配得分 1，否则得分 0。
    """
    try:
        user_answer = item.get("action", "").strip().lower()
        original_word = item.get("original_word", "").lower()
        if user_answer == original_word:
            item["score"] = 1
        else:
            item["score"] = 0
    except Exception as e:
        print(f"验证过程中出现错误: {e}")
        item["score"] = 0
    return item

# ------------------------------
# FastAPI请求数据模型
# ------------------------------
class GenerateRequest(BaseModel):
    seed: int

class BoardRequest(BaseModel):
    board: str

class GameState(BaseModel):
    question: str
    answer: str
    score: int
    is_end: bool
    response: list
    prompt: str
    action: str
    epoch: int
    original_word: str = None  # 隐藏原始单词，仅用于验证
    rules: list = []
    transformed_word: str

# ------------------------------
# FastAPI接口配置
# ------------------------------
app = FastAPI()

@app.post("/generate", response_model=GameState)
def api_generate(request: GenerateRequest):
    item = generate(request.seed)
    return item

@app.post("/print_board", response_model=BoardRequest)
def api_print_board(state: GameState):
    board_output = print_board(state.dict())
    return {"board": board_output}

@app.post("/verify", response_model=GameState)
def api_verify(state: GameState):
    updated_state = verify(state.dict())
    return updated_state

if __name__ == "__main__":
    args = parse_init()
    uvicorn.run(app, host=args.host, port=args.port)
