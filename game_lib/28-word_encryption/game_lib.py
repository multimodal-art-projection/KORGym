import os
import random
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn
import argparse
def parse_init():
    """
    å®šä¹‰å¹¶è§£æevalä»£ç çš„å‘½ä»¤è¡Œå‚æ•°ï¼Œé…ç½®æ—¥å¿—è®°å½•ï¼Œå¹¶æ£€æŸ¥è¾“å…¥çš„æ•°æ®æ–‡ä»¶ç›®å½•å’Œè¾“å‡ºçš„ç›®å½•æ˜¯å¦å­˜åœ¨ã€‚
    """
    parser = argparse.ArgumentParser(description="Data creation utility")

    # æ·»åŠ å‘½ä»¤è¡Œå‚æ•°
    parser.add_argument('-p', '--port', type=int, default=8775, help='æœåŠ¡éƒ¨ç½²ç«¯å£')
    # æ·»åŠ å‘½ä»¤è¡Œå‚æ•°
    parser.add_argument('-H', '--host', type=str, default="0.0.0.0", help='æœåŠ¡éƒ¨ç½²åœ°å€')
    # è§£æå‘½ä»¤è¡Œå‚æ•°
    args = parser.parse_args()
    return args
game_prompt="""
You are a good game player, I'll give you a game board and rules.\nYour task is:\n- First, give your answer according to the game board and rules.\n- Second, output the answer in the required format. The last line of your response should be in the following format: 'Answer: $YOUR_ANSWER' (without quotes), where YOUR_ANSWER is your final answer to the question,e.g.'Answer: 12'
{board}
"""
# ------------------------------
# è¯»å–å•è¯åŠè¾…åŠ©å‡½æ•°
# ------------------------------
words = []
mapping_table_str = """
'A': 'ğŸ˜€ğŸğŸš—', 'B': 'ğŸ¶ğŸŒŸğŸ“š', 'C': 'ğŸŒˆğŸ€ğŸš€', 'D': 'ğŸ±ğŸ‰ğŸ€',
        'E': 'ğŸ”ğŸ‰ğŸˆ', 'F': 'ğŸŒ¸ğŸ©ğŸ°', 'G': 'ğŸ¦‹ğŸ‡âš½', 'H': 'ğŸ•ğŸ‚ğŸï¸',
        'I': 'ğŸ¦ğŸğŸ§', 'J': 'ğŸ¸ğŸ’ğŸ†', 'K': 'ğŸ¦„ğŸ“ğŸ®', 'L': 'ğŸ°ğŸğŸ“·',
        'M': 'ğŸŒ¹ğŸŒğŸ¨', 'N': 'ğŸ¼ğŸğŸ¤', 'O': 'ğŸ‰ğŸµğŸ“š', 'P': 'ğŸŒ¼ğŸ‡ğŸ¬',
        'Q': 'ğŸ¢ğŸ“ğŸ¯', 'R': 'ğŸ’ğŸ¸ğŸ“±', 'S': 'ğŸŒ»ğŸğŸ²', 'T': 'ğŸ¯ğŸŒğŸ®',
        'U': 'ğŸ“ğŸ¹ğŸ“–', 'V': 'ğŸŒºğŸ‰ğŸ¥', 'W': 'ğŸ³ğŸğŸ­', 'X': 'ğŸğŸ¤ğŸ“¡',
        'Y': 'ğŸ¥ğŸ‡ğŸ¨', 'Z': 'ğŸŒµğŸ’ğŸ®'
"""
try:
    with open("words.txt", "r", encoding="utf-8") as f:
        for line in f:
            w = line.strip()
            if len(w) <= 2:
                continue
            words.append(w)
except Exception as e:
    raise Exception("è¯»å– words.txt å‡ºé”™: " + str(e))

# ------------------------------
# è¾…åŠ©è½¬æ¢å‡½æ•°
# ------------------------------
def char_drift(c):
    # å°†å­—æ¯å‘åç§»åŠ¨ä¸€ä½ï¼Œz åå›åˆ° a
    return chr((ord(c) - ord('a') + 1) % 26 + ord('a'))

def char2emoji(c):
    mapping = {
        'A': 'ğŸ˜€ğŸğŸš—', 'B': 'ğŸ¶ğŸŒŸğŸ“š', 'C': 'ğŸŒˆğŸ€ğŸš€', 'D': 'ğŸ±ğŸ‰ğŸ€',
        'E': 'ğŸ”ğŸ‰ğŸˆ', 'F': 'ğŸŒ¸ğŸ©ğŸ°', 'G': 'ğŸ¦‹ğŸ‡âš½', 'H': 'ğŸ•ğŸ‚ğŸï¸',
        'I': 'ğŸ¦ğŸğŸ§', 'J': 'ğŸ¸ğŸ’ğŸ†', 'K': 'ğŸ¦„ğŸ“ğŸ®', 'L': 'ğŸ°ğŸğŸ“·',
        'M': 'ğŸŒ¹ğŸŒğŸ¨', 'N': 'ğŸ¼ğŸğŸ¤', 'O': 'ğŸ‰ğŸµğŸ“š', 'P': 'ğŸŒ¼ğŸ‡ğŸ¬',
        'Q': 'ğŸ¢ğŸ“ğŸ¯', 'R': 'ğŸ’ğŸ¸ğŸ“±', 'S': 'ğŸŒ»ğŸğŸ²', 'T': 'ğŸ¯ğŸŒğŸ®',
        'U': 'ğŸ“ğŸ¹ğŸ“–', 'V': 'ğŸŒºğŸ‰ğŸ¥', 'W': 'ğŸ³ğŸğŸ­', 'X': 'ğŸğŸ¤ğŸ“¡',
        'Y': 'ğŸ¥ğŸ‡ğŸ¨', 'Z': 'ğŸŒµğŸ’ğŸ®'
    }
    new_mapping = {k.lower(): v for k, v in mapping.items()}
    return new_mapping.get(c, c)

def Transform_1(word):
    # æ¯ä¸ªå­—æ¯é‡å¤ä¸¤æ¬¡ï¼Œä¾‹å¦‚ "happy" -> "hhaappppyy"
    return "".join([c * 2 for c in word])

def Transform_2(word):
    # æ¯ä¸ªå­—æ¯å³ç§»ä¸€ä½ï¼Œä¾‹å¦‚ "happy" -> "ibqqz"
    return "".join([char_drift(c) for c in word])

def Transform_3(word):
    # å­—ç¬¦ä¸²å¾ªç¯å³ç§»ä¸€ä½ï¼Œä¾‹å¦‚ "happy" -> "yhapp"
    return word[-1] + word[:-1] if word else word

def Transform_4(word):
    # åè½¬å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "happy" -> "yppah"
    return word[::-1]

def Transform_5(word):
    # å­—ç¬¦ä¸²å·¦ç§»ä¸¤ä½ï¼Œä¾‹å¦‚ "happy" -> "ppyha"
    return word[2:] + word[:2] if len(word) > 2 else word

def Transform_6(word):
    # å¯¹å¶æ•°ä½ç½®çš„å­—æ¯è¿›è¡Œè½®è½¬ï¼Œä¾‹å¦‚ "happy" -> "hbpqy"
    return "".join([char_drift(c) if i % 2 == 0 else c for i, c in enumerate(word)])

def Transform_7(word):
    # å¯¹å¥‡æ•°ä½ç½®çš„å­—æ¯è¿›è¡Œè½®è½¬ï¼Œä¾‹å¦‚ "happy" -> "iaqpz"
    return "".join([char_drift(c) if i % 2 == 1 else c for i, c in enumerate(word)])

def Transform_8(word):
    # å°†å­—æ¯è½¬æ¢ä¸ºå¯¹åº”çš„ emoji å­—ç¬¦ä¸²
    return "".join([char2emoji(c) for c in word])

rule_functions = {
    "Transform_1": Transform_1,
    "Transform_2": Transform_2,
    "Transform_3": Transform_3,
    "Transform_4": Transform_4,
    "Transform_5": Transform_5,
    "Transform_6": Transform_6,
    "Transform_7": Transform_7,
    "Transform_8": Transform_8,
}

def compute_transformed_word(word, rules):
    for rule in rules:
        word = rule_functions[rule](word)
    return word

desc = f"""This game provides you with a transformed word generated by applying a series of transformations on an original word.
Your task is to recover the original word.
Transformations:
Transform_1: Repeat each letter (e.g. "happy" -> "hhaappppyy").
Transform_2: Shift each letter to the next letter (e.g. "happy" -> "ibqqz").
Transform_3: Cyclic shift right by one (e.g. "happy" -> "yhapp").
Transform_4: Reverse the word (e.g. "happy" -> "yppah").
Transform_5: Cyclic shift left by two (e.g. "happy" -> "ppyha").
Transform_6: Shift even-indexed letters (e.g. "happy" -> "hbpqy").
Transform_7: Shift odd-indexed letters (e.g. "happy" -> "iaqpz").
Transform_8: Convert letters to emojis.Mapping table:{mapping_table_str}
"""

# ------------------------------
# æ¥å£1ï¼šgenerate
# ------------------------------
def generate(seed: int) -> dict:
    """
    æ ¹æ®ç»™å®šç§å­ç”Ÿæˆæ¸¸æˆçŠ¶æ€ï¼š
      1. ä» words.txt ä¸­è¯»å–åˆæ³•å•è¯ï¼ˆé•¿åº¦å¤§äº2ï¼‰ï¼›
      2. éšæœºç”Ÿæˆä¸€ç³»åˆ—è½¬æ¢è§„åˆ™ï¼ˆ2è‡³10ä¸ªï¼Œæœ€åä¸€æ¡å›ºå®šä¸º Transform_8ï¼‰ï¼›
      3. éšæœºé€‰æ‹©ä¸€ä¸ªåŸå§‹å•è¯å¹¶è®¡ç®—è½¬æ¢åçš„å•è¯ï¼›
      4. æ„é€ æç¤ºä¿¡æ¯ã€‚
    è¿”å›çš„ item åŒ…å«éšè—çš„åŸå§‹å•è¯ã€è½¬æ¢è§„åˆ™åŠè½¬æ¢åçš„å•è¯ã€‚
    """
    random.seed(seed)
    if not words:
        raise Exception("words.txt ä¸­æœªæ‰¾åˆ°åˆæ³•å•è¯ã€‚")
    
    # ç”Ÿæˆéšæœºè½¬æ¢è§„åˆ™æ•°é‡ï¼ˆè‡³å°‘2ä¸ªè§„åˆ™ï¼Œæœ€å¤š10ä¸ªè§„åˆ™ï¼‰
    rules_num = random.randint(2, 10)
    rules = []
    for i in range(rules_num - 1):
        k = random.choice(list(range(1, 8)))
        rules.append("Transform_%d" % k)
    rules.append("Transform_8")  # æœ€åä¸€æ¡è§„åˆ™å›ºå®šä¸º Transform_8

    original_word = random.choice(words)
    transformed_word = compute_transformed_word(original_word, rules)
    
    prompt_text = (
        "Game rules: " + desc + "\n" +
        "Transformed word: " + transformed_word + "\n" +
        "Transforms applied: " + ", ".join(rules) + "\n" +
        "Please recover the original word from the above transformed word.\n"
    )
    
    item = {
        "answer": "",
        "question": prompt_text,
        "score": 0,
        "is_end": False,
        "response": [],
        "prompt": "",
        "action": "",
        "epoch": 1,
        "original_word": original_word,        # éšè—çš„åŸå§‹å•è¯ï¼Œä»…ç”¨äºéªŒè¯
        "rules": rules,
        "transformed_word": transformed_word,  # æ˜¾ç¤ºç»™ç©å®¶çš„è½¬æ¢ç»“æœ
    }
    return item

# ------------------------------
# æ¥å£2ï¼šprint_board
# ------------------------------
def print_board(item: dict) -> str:
    """
    è¿”å›ç”Ÿæˆçš„æ¸¸æˆæç¤ºä¿¡æ¯ã€‚
    """
    return game_prompt.format(board = item.get("question", ""))

# ------------------------------
# æ¥å£3ï¼šverify
# ------------------------------
def verify(item: dict) -> dict:
    """
    æ ¹æ® item ä¸­çš„ actionï¼ˆç©å®¶è¾“å…¥çš„ç­”æ¡ˆï¼‰æ ¡éªŒç­”æ¡ˆæ˜¯å¦æ­£ç¡®ï¼š
      1. è·å–éšè—çš„åŸå§‹å•è¯ï¼›
      2. æ¯”è¾ƒç©å®¶è¾“å…¥ç­”æ¡ˆä¸åŸå§‹å•è¯ï¼Œå®Œå…¨åŒ¹é…å¾—åˆ† 1ï¼Œå¦åˆ™å¾—åˆ† 0ã€‚
    """
    try:
        user_answer = item.get("action", "").strip().lower()
        original_word = item.get("original_word", "").lower()
        if user_answer == original_word:
            item["score"] = 1
        else:
            item["score"] = 0
    except Exception as e:
        print(f"éªŒè¯è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
        item["score"] = 0
    return item

# ------------------------------
# FastAPIè¯·æ±‚æ•°æ®æ¨¡å‹
# ------------------------------
class GenerateRequest(BaseModel):
    seed: int

class BoardRequest(BaseModel):
    board: str

class GameState(BaseModel):
    question: str
    answer: str
    score: int
    is_end: bool
    response: list
    prompt: str
    action: str
    epoch: int
    original_word: str = None  # éšè—åŸå§‹å•è¯ï¼Œä»…ç”¨äºéªŒè¯
    rules: list = []
    transformed_word: str

# ------------------------------
# FastAPIæ¥å£é…ç½®
# ------------------------------
app = FastAPI()

@app.post("/generate", response_model=GameState)
def api_generate(request: GenerateRequest):
    item = generate(request.seed)
    return item

@app.post("/print_board", response_model=BoardRequest)
def api_print_board(state: GameState):
    board_output = print_board(state.dict())
    return {"board": board_output}

@app.post("/verify", response_model=GameState)
def api_verify(state: GameState):
    updated_state = verify(state.dict())
    return updated_state

if __name__ == "__main__":
    args = parse_init()
    uvicorn.run(app, host=args.host, port=args.port)
